//
// Created by bdwms on 2020/5/2.
//
#include <vector>

using namespace std;

/*
 * 定义下一个字典排序
 * 我们需要将后面的大数字替换前面小的，但是幅度要小，所以
 * 1.在尽可能靠右的低位进行交换，需要从后向前查找
 * 2.将一个 尽可能小的「大数」 与前面的「小数」交换。比如 123465，下一个排列应该把 5 和 4 交换而不是把 6 和 4 交换
 * 3.将「大数」换到前面后，需要将「大数」后面的所有数重置为升序，升序排列就是最小的排列。
 *   以 123465 为例：首先按照上一步，交换 5 和 4，得到 123564；然后需要将 5 之后的数重置为升序，得到 123546。
 *   显然 123546 比 123564 更小，123546 就是 123465 的下一个排列
 *
 * 所以我们需要首先寻找左值，即第一个小于后面某个数的数字，即打断了从后往前的上升趋势的数，这样才能保证新的数是较大的
 * 然后我们找右值，右值肯定需要找比左值小于等于的数字交换才有意义
 * 然后交换左值和右值后，需要对大数后面整个进行升序排序，为什么呢？
 * 因为越低位的权值越低所以需要放更大的数
 * 时间复杂度O(2n)=O(n),最坏只要扫描两次
 * 空间复杂度O(1)
 */
class Solution {
 public:
  void nextPermutation(vector<int> &nums) {
    int n = nums.size(), i = n - 2, j = n - 1; // i用来寻找需要替换的左值，j用来寻找替换的右值
    while (i >= 0 && nums[i] >= nums[i + 1]) i--;
    if (i >= 0) {
      while (nums[i] >= nums[j]) j--;
      swap(nums[i], nums[j]);
    }
    reverse(nums.begin() + i + 1, nums.end());
  }
};